import React, { CSSProperties, ReactNode, RefObject, Key, ReactElement, HTMLAttributes, LabelHTMLAttributes, InputHTMLAttributes, ForwardedRef, TextareaHTMLAttributes } from "react";
import { CollectionBase, DraggableCollectionProps, DroppableCollectionProps, AriaLabelingProps, InputDOMProps, ValidationState as _ValidationState1 } from "@react-types/shared";
import { SelectionBehavior, SelectionMode, ItemProps as _ItemProps1, SectionProps as _SectionProps1, CalendarState, RangeCalendarState, ValidationState, CheckboxGroupState, DraggableCollectionState, DraggableCollectionStateOptions, DroppableCollectionState, DroppableCollectionStateOptions, ListState, Orientation, OverlayTriggerProps, OverlayTriggerState, ComboBoxState, DateFieldState, DateSegmentType, DateSegment as _DateSegment1, DatePickerState, DateRangePickerState, MenuTriggerProps as _MenuTriggerProps1, NumberFieldState, RadioGroupState, SearchFieldState, SelectState, SliderState, ToggleState, DisabledBehavior, SortDirection, TableState, TabListState, TooltipTriggerProps, TooltipTriggerState } from "react-stately";
import { AriaLinkOptions, AriaBreadcrumbsProps, AriaButtonProps, CalendarProps as _CalendarProps1, RangeCalendarProps as _RangeCalendarProps1, DateValue, AriaCheckboxGroupProps, AriaCheckboxProps, DropIndicatorProps as _DropIndicatorProps1, DraggableCollectionOptions, DraggableItemProps, DraggableItemResult, DragItem, DragPreview, DropIndicatorAria, DroppableCollectionOptions, DroppableCollectionResult, DroppableItemOptions, DroppableItemResult, DropTarget, DropTargetDelegate, ListDropTargetDelegate, SeparatorProps as _SeparatorProps1, AriaListBoxProps, PlacementAxis, AriaPopoverProps, PositionProps, AriaComboBoxProps, AriaDateFieldProps, AriaTimeFieldProps, TimeValue, AriaModalOverlayProps, AriaDialogProps, AriaDatePickerProps, AriaDateRangePickerProps, DropOptions, AriaGridListProps, AriaMenuProps, AriaMeterProps, AriaNumberFieldProps, AriaProgressBarProps, AriaRadioGroupProps, AriaRadioProps, Orientation as _Orientation1, AriaSearchFieldProps, AriaSelectProps, AriaSliderProps, AriaSliderThumbProps, AriaSwitchProps, AriaTabListProps, AriaTabPanelProps, AriaTagGroupProps, AriaTextFieldProps, AriaToggleButtonProps } from "react-aria";
import { CalendarDate, DateDuration } from "@internationalized/date";
import { ColumnSize, ColumnStaticSize, TableProps as _TableProps1 } from "@react-types/table";
declare const slotCallbackSymbol: unique symbol;
interface SlottedValue<T> {
    slots?: Record<string | symbol, T>;
    [slotCallbackSymbol]?: (value: T) => void;
}
export type ContextValue<T extends SlotProps, E extends Element> = SlottedValue<WithRef<T, E>> | WithRef<T, E> | null | undefined;
type ProviderValue<T> = [React.Context<T>, T];
type ProviderValues<A, B, C, D, E, F, G, H> = [ProviderValue<A>] | [ProviderValue<A>, ProviderValue<B>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>, ProviderValue<G>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>, ProviderValue<G>, ProviderValue<H>];
interface ProviderProps<A, B, C, D, E, F, G, H> {
    values: ProviderValues<A, B, C, D, E, F, G, H>;
    children: React.ReactNode;
}
export function Provider<A, B, C, D, E, F, G, H>({ values, children }: ProviderProps<A, B, C, D, E, F, G, H>): JSX.Element;
interface StyleProps {
    /** The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. */
    className?: string;
    /** The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) for the element. */
    style?: CSSProperties;
}
interface DOMProps extends StyleProps {
    /** The children of the component. */
    children?: ReactNode;
}
interface StyleRenderProps<T> {
    /** The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state. */
    className?: string | ((values: T) => string);
    /** The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) for the element. A function may be provided to compute the style based on component state. */
    style?: CSSProperties | ((values: T) => CSSProperties);
}
interface RenderProps<T> extends StyleRenderProps<T> {
    /** The children of the component. A function may be provided to alter the children based on component state. */
    children?: ReactNode | ((values: T) => ReactNode);
}
type WithRef<T, E> = T & {
    ref?: React.ForwardedRef<E>;
};
export interface SlotProps {
    /** A slot name for the component. Slots allow the component to receive props from a parent component. */
    slot?: string;
}
export function useContextProps<T, U extends SlotProps, E extends Element>(props: T & SlotProps, ref: React.ForwardedRef<E>, context: React.Context<ContextValue<U, E>>): [T, React.RefObject<E>];
interface CollectionProps<T> extends Omit<CollectionBase<T>, 'children'> {
    /** The contents of the collection. */
    children?: ReactNode | ((item: T) => ReactNode);
}
export interface ItemRenderProps {
    /**
     * Whether the item is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the item is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the item is currently selected.
     * @selector [aria-selected=true]
     */
    isSelected: boolean;
    /**
     * Whether the item is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the item is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may
     * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /** The type of selection that is allowed in the collection. */
    selectionMode: SelectionMode;
    /** The selection behavior for the collection. */
    selectionBehavior: SelectionBehavior;
    /**
     * Whether the item allows dragging.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [draggable]
     */
    allowsDragging?: boolean;
    /**
     * Whether the item is currently being dragged.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [data-dragging]
     */
    isDragging?: boolean;
    /**
     * Whether the item is currently an active drop target.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [data-drop-target]
     */
    isDropTarget?: boolean;
}
export interface ItemProps<T = object> extends Omit<_ItemProps1<T>, 'children'>, RenderProps<ItemRenderProps> {
    /** The unique id of the item. */
    id?: Key;
    /** The object value that this item represents. When using dynamic collections, this is set automatically. */
    value?: T;
}
export const Item: <T extends object>(props: ItemProps<T> & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SectionProps<T> extends Omit<_SectionProps1<T>, 'children' | 'title'>, StyleProps {
    /** The unique id of the section. */
    id?: Key;
    /** The object value that this section represents. When using dynamic collections, this is set automatically. */
    value?: T;
    /** Static child items or a function to render children. */
    children?: ReactNode | ((item: T) => ReactElement);
}
export const Section: <T extends object>(props: SectionProps<T> & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/** A Collection renders a list of items, automatically managing caching and keys. */
export function Collection<T extends object>(props: CollectionProps<T>): JSX.Element;
export interface HeadingProps extends HTMLAttributes<HTMLElement> {
    level?: number;
}
export const HeadingContext: React.Context<ContextValue<HeadingProps, HTMLHeadingElement>>;
export const Heading: React.ForwardRefExoticComponent<HeadingProps & React.RefAttributes<HTMLHeadingElement>>;
export interface LinkProps extends Omit<AriaLinkOptions, 'elementType'>, RenderProps<LinkRenderProps>, SlotProps {
}
export interface LinkRenderProps {
    /**
     * Whether the link is the current item within a list.
     * @selector [aria-current]
     */
    isCurrent: boolean;
    /**
     * Whether the link is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the link is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the link is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the link is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the link is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
}
export const LinkContext: React.Context<ContextValue<LinkProps, HTMLAnchorElement>>;
/**
 * A link allows a user to navigate to another page or resource within a web page
 * or application.
 */
export const Link: (props: LinkProps & React.RefAttributes<HTMLAnchorElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface BreadcrumbsProps<T> extends Omit<CollectionProps<T>, 'disabledKeys'>, Omit<AriaBreadcrumbsProps, 'children'>, StyleProps, SlotProps {
    /** Whether the breadcrumbs are disabled. */
    isDisabled?: boolean;
}
export const BreadcrumbsContext: React.Context<ContextValue<BreadcrumbsProps<any>, HTMLElement>>;
/**
 * Breadcrumbs display a heirarchy of links to the current page or resource in an application.
 */
export const Breadcrumbs: <T extends object>(props: BreadcrumbsProps<T> & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ButtonRenderProps {
    /**
     * Whether the button is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the button is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the button is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the button is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the button is disabled.
     * @selector :disabled
     */
    isDisabled: boolean;
}
export interface ButtonProps extends Omit<AriaButtonProps, 'children' | 'href' | 'target' | 'rel' | 'elementType'>, SlotProps, RenderProps<ButtonRenderProps> {
    /**
     * The <form> element to associate the button with.
     * The value of this attribute must be the id of a <form> in the same document.
     */
    form?: string;
    /**
     * The URL that processes the information submitted by the button.
     * Overrides the action attribute of the button's form owner.
     */
    formAction?: string;
    /** Indicates how to encode the form data that is submitted. */
    formEncType?: string;
    /** Indicates the HTTP method used to submit the form. */
    formMethod?: string;
    /** Indicates that the form is not to be validated when it is submitted. */
    formNoValidate?: boolean;
    /** Overrides the target attribute of the button's form owner. */
    formTarget?: string;
    /** Submitted as a pair with the button's value as part of the form data. */
    name?: string;
    /** The value associated with the button's name when it's submitted with the form data. */
    value?: string;
}
interface ButtonContextValue extends ButtonProps {
    isPressed?: boolean;
}
export const ButtonContext: React.Context<ContextValue<ButtonContextValue, HTMLButtonElement>>;
/**
 * A button allows a user to perform an action, with mouse, touch, and keyboard interactions.
 */
export const Button: (props: ButtonProps & React.RefAttributes<HTMLButtonElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TextProps extends HTMLAttributes<HTMLElement> {
    elementType?: string;
}
export const TextContext: React.Context<ContextValue<TextProps, HTMLElement>>;
export const Text: React.ForwardRefExoticComponent<TextProps & React.RefAttributes<HTMLElement>>;
export interface CalendarRenderProps {
    /**
     * Whether the calendar is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * State of the calendar.
     */
    state: CalendarState;
    /**
     * Validation state of the date field.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState;
}
export interface RangeCalendarRenderProps extends Omit<CalendarRenderProps, 'state'> {
    /**
     * State of the range calendar.
     */
    state: RangeCalendarState;
}
export interface CalendarProps<T extends DateValue> extends Omit<_CalendarProps1<T>, 'errorMessage'>, RenderProps<CalendarRenderProps>, SlotProps {
    /**
     * The amount of days that will be displayed at once. This affects how pagination works.
     * @default {months: 1}
     */
    visibleDuration?: DateDuration;
}
export interface RangeCalendarProps<T extends DateValue> extends Omit<_RangeCalendarProps1<T>, 'errorMessage'>, RenderProps<RangeCalendarRenderProps>, SlotProps {
    /**
     * The amount of days that will be displayed at once. This affects how pagination works.
     * @default {months: 1}
     */
    visibleDuration?: DateDuration;
}
export const CalendarContext: React.Context<ContextValue<CalendarProps<any>, HTMLDivElement>>;
export const RangeCalendarContext: React.Context<ContextValue<RangeCalendarProps<any>, HTMLDivElement>>;
/**
 * A calendar displays one or more date grids and allows users to select a single date.
 */
export const Calendar: <T extends DateValue>(props: CalendarProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.
 */
export const RangeCalendar: <T extends DateValue>(props: RangeCalendarProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CalendarCellRenderProps {
    /** The date that the cell represents. */
    date: CalendarDate;
    /** The day number formatted according to the current locale. */
    formattedDate: string;
    /**
     * Whether the cell is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the cell is currently being pressed.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the cell is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the cell is the first date in a range selection.
     * @selector [data-selection-start]
     */
    isSelectionStart: boolean;
    /**
     * Whether the cell is the last date in a range selection.
     * @selector [data-selection-end]
     */
    isSelectionEnd: boolean;
    /**
     * Whether the cell is focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the cell is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the cell is disabled, according to the calendar's `minValue`, `maxValue`, and `isDisabled` props.
     * Disabled dates are not focusable, and cannot be selected by the user. They are typically
     * displayed with a dimmed appearance.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the cell is outside the visible range of the calendar.
     * For example, dates before the first day of a month in the same week.
     * @selector [data-outside-visible-range]
     */
    isOutsideVisibleRange: boolean;
    /**
     * Whether the cell is outside the current month.
     * @selector [data-outside-month]
     */
    isOutsideMonth: boolean;
    /**
     * Whether the cell is unavailable, according to the calendar's `isDateUnavailable` prop. Unavailable dates remain
     * focusable, but cannot be selected by the user. They should be displayed with a visual affordance to indicate they
     * are unavailable, such as a different color or a strikethrough.
     *
     * Note that because they are focusable, unavailable dates must meet a 4.5:1 color contrast ratio,
     * [as defined by WCAG](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html).
     *
     * @selector [data-unavailable]
     */
    isUnavailable: boolean;
    /**
     * Whether the cell is part of an invalid selection.
     * @selector [aria-invalid]
     */
    isInvalid: boolean;
}
export interface CalendarGridProps extends StyleProps {
    /**
     * Either a function to render calendar cells for each date in the month,
     * or children containing a `<CalendarGridHeader>`` and `<CalendarGridBody>`
     * when additional customization is needed.
     */
    children?: ReactElement | ReactElement[] | ((date: CalendarDate) => ReactElement);
    /**
     * An offset from the beginning of the visible date range that this
     * CalendarGrid should display. Useful when displaying more than one
     * month at a time.
     */
    offset?: DateDuration;
    /**
     * The style of weekday names to display in the calendar grid header,
     * e.g. single letter, abbreviation, or full day name.
     * @default "narrow"
     */
    weekdayStyle?: 'narrow' | 'short' | 'long';
}
/**
 * A calendar grid displays a single grid of days within a calendar or range calendar which
 * can be keyboard navigated and selected by the user.
 */
export const CalendarGrid: (props: CalendarGridProps & React.RefAttributes<HTMLTableElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CalendarGridHeaderProps extends StyleProps {
    /** A function to render a `<CalendarHeaderCell>` for a weekday name. */
    children: (day: string) => ReactElement;
}
/**
 * A calendar grid header displays a row of week day names at the top of a month.
 */
export const CalendarGridHeader: (props: CalendarGridHeaderProps & React.RefAttributes<HTMLTableSectionElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CalendarHeaderCellProps extends DOMProps {
}
/**
 * A calendar header cell displays a week day name at the top of a column within a calendar.
 */
export const CalendarHeaderCell: React.ForwardRefExoticComponent<CalendarHeaderCellProps & React.RefAttributes<HTMLTableCellElement>>;
export interface CalendarGridBodyProps extends StyleProps {
    /** A function to render a `<CalendarCell>` for a given date. */
    children: (date: CalendarDate) => ReactElement;
}
/**
 * A calendar grid body displays a grid of calendar cells within a month.
 */
export const CalendarGridBody: (props: CalendarGridBodyProps & React.RefAttributes<HTMLTableSectionElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CalendarCellProps extends RenderProps<CalendarCellRenderProps> {
    /** The date to render in the cell. */
    date: CalendarDate;
}
/**
 * A calendar cell displays a date cell within a calendar grid which can be selected by the user.
 */
export const CalendarCell: (props: CalendarCellProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface LabelProps extends LabelHTMLAttributes<HTMLLabelElement> {
    elementType?: string;
}
export const LabelContext: React.Context<ContextValue<LabelProps, HTMLLabelElement>>;
export const Label: React.ForwardRefExoticComponent<LabelProps & React.RefAttributes<HTMLLabelElement>>;
export interface CheckboxGroupProps extends Omit<AriaCheckboxGroupProps, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<CheckboxGroupRenderProps>, SlotProps {
}
export interface CheckboxProps extends Omit<AriaCheckboxProps, 'children'>, RenderProps<CheckboxRenderProps>, SlotProps {
}
export interface CheckboxGroupRenderProps {
    /**
     * Whether the checkbox group is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the checkbox group is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the checkbox group is required.
     * @selector [data-required]
     */
    isRequired: boolean;
    /**
     * The validation state of the checkbox group.
     * @selector [data-validation-state="invalid" | "valid"]
     */
    validationState: ValidationState;
    /**
     * State of the checkbox group.
     */
    state: CheckboxGroupState;
}
export interface CheckboxRenderProps {
    /**
     * Whether the checkbox is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the checkbox is indeterminate.
     * @selector [data-indeterminate]
     */
    isIndeterminate: boolean;
    /**
     * Whether the checkbox is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the checkbox is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the checkbox is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the checkbox is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the checkbox is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the checkbox is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the checkbox is valid or invalid.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | undefined;
    /**
     * Whether the checkbox is required.
     * @selector [data-required]
     */
    isRequired: boolean;
}
export const CheckboxGroupContext: React.Context<ContextValue<CheckboxGroupProps, HTMLDivElement>>;
export const CheckboxContext: React.Context<ContextValue<CheckboxProps, HTMLInputElement>>;
/**
 * A checkbox allows a user to select multiple items from a list of individual items, or
 * to mark one individual item as selected.
 */
export const Checkbox: (props: CheckboxProps & React.RefAttributes<HTMLInputElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A checkbox group allows a user to select multiple items from a list of options.
 */
export const CheckboxGroup: (props: CheckboxGroupProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface InputRenderProps {
    /**
     * Whether the input is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the input is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the input is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the input is disabled.
     * @selector :disabled
     */
    isDisabled: boolean;
}
export interface InputProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'className' | 'style'>, StyleRenderProps<InputRenderProps> {
}
export const InputContext: React.Context<ContextValue<InputProps, HTMLInputElement>>;
/**
 * An input allows a user to input text.
 */
export const Input: React.ForwardRefExoticComponent<InputProps & React.RefAttributes<HTMLInputElement>>;
interface DraggableCollectionStateOpts extends Omit<DraggableCollectionStateOptions, 'getItems'> {
}
interface DragHooks {
    useDraggableCollectionState?: (props: DraggableCollectionStateOpts) => DraggableCollectionState;
    useDraggableCollection?: (props: DraggableCollectionOptions, state: DraggableCollectionState, ref: RefObject<HTMLElement>) => void;
    useDraggableItem?: (props: DraggableItemProps, state: DraggableCollectionState) => DraggableItemResult;
    DragPreview?: typeof DragPreview;
    renderDragPreview?: (items: DragItem[]) => JSX.Element;
}
interface DropHooks {
    useDroppableCollectionState?: (props: DroppableCollectionStateOptions) => DroppableCollectionState;
    useDroppableCollection?: (props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DroppableCollectionResult;
    useDroppableItem?: (options: DroppableItemOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DroppableItemResult;
    useDropIndicator?: (props: _DropIndicatorProps1, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DropIndicatorAria;
    renderDropIndicator?: (target: DropTarget) => JSX.Element;
    dropTargetDelegate?: DropTargetDelegate;
    ListDropTargetDelegate: typeof ListDropTargetDelegate;
}
export type DragAndDropHooks = DragHooks & DropHooks;
interface DragAndDrop {
    /** Drag and drop hooks for the collection element.  */
    dragAndDropHooks: DragAndDropHooks;
}
export interface DragAndDropOptions extends Omit<DraggableCollectionProps, 'preview' | 'getItems'>, DroppableCollectionProps {
    /**
     * A function that returns the items being dragged. If not specified, we assume that the collection is not draggable.
     * @default () => []
     */
    getItems?: (keys: Set<Key>) => DragItem[];
    /**
     * A function that renders a drag preview, which is shown under the user's cursor while dragging.
     * By default, a copy of the dragged element is rendered.
     */
    renderDragPreview?: (items: DragItem[]) => JSX.Element;
    /**
     * A function that renders a drop indicator element between two items in a collection.
     * This should render a `<DropIndicator>` element. If this function is not provided, a
     * default DropIndicator is provided.
     */
    renderDropIndicator?: (target: DropTarget) => JSX.Element;
    /** A custom delegate object that provides drop targets for pointer coordinates within the collection. */
    dropTargetDelegate?: DropTargetDelegate;
}
/**
 * Provides the hooks required to enable drag and drop behavior for a drag and drop compatible collection component.
 */
export function useDragAndDrop(options: DragAndDropOptions): DragAndDrop;
export const DropIndicatorContext: React.Context<DropIndicatorContextValue>;
interface DropIndicatorRenderProps {
    /**
     * Whether the drop indicator is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
export interface DropIndicatorProps extends _DropIndicatorProps1, RenderProps<DropIndicatorRenderProps> {
}
interface DropIndicatorContextValue {
    render: (props: DropIndicatorProps, ref: ForwardedRef<HTMLElement>) => ReactNode;
}
/**
 * A DropIndicator is rendered between items in a collection to indicate where dropped data will be inserted.
 */
export const DropIndicator: React.ForwardRefExoticComponent<DropIndicatorProps & React.RefAttributes<HTMLElement>>;
export const Header: React.ForwardRefExoticComponent<React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>>;
export interface SeparatorProps extends _SeparatorProps1, StyleProps, SlotProps {
}
export const SeparatorContext: React.Context<ContextValue<SeparatorProps, Element>>;
export const Separator: React.ForwardRefExoticComponent<SeparatorProps & React.RefAttributes<Element>>;
export interface ListBoxRenderProps {
    /**
     * Whether the listbox has no items and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the listbox is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the listbox is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the listbox is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
    /**
     * State of the listbox.
     */
    state: ListState<unknown>;
}
export interface ListBoxProps<T> extends Omit<AriaListBoxProps<T>, 'children'>, CollectionProps<T>, StyleRenderProps<ListBoxRenderProps>, SlotProps {
    /** How multiple selection should behave in the collection. */
    selectionBehavior?: SelectionBehavior;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the ListBox. */
    dragAndDropHooks?: DragAndDropHooks;
    /** Provides content to display when there are no items in the list. */
    renderEmptyState?: () => ReactNode;
    /**
     * Whether the items are arranged in a stack or grid.
     * @default 'stack'
     */
    layout?: 'stack' | 'grid';
    /**
     * The primary orientation of the items. Usually this is the
     * direction that the collection scrolls.
     * @default 'vertical'
     */
    orientation?: Orientation;
}
interface ListBoxContextValue<T> extends ListBoxProps<T> {
    state?: ListState<T>;
}
export const ListBoxContext: React.Context<ContextValue<ListBoxContextValue<any>, HTMLDivElement>>;
/**
 * A listbox displays a list of options and allows a user to select one or more of them.
 */
export const ListBox: <T>(props: ListBoxProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface OverlayArrowProps extends Omit<HTMLAttributes<HTMLDivElement>, 'className' | 'style' | 'children'>, RenderProps<OverlayArrowRenderProps> {
}
export interface OverlayArrowRenderProps {
    /**
     * The placement of the overlay relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
}
/**
 * An OverlayArrow renders a custom arrow element relative to an overlay element
 * such as a popover or tooltip such that it aligns with a trigger element.
 */
export const OverlayArrow: (props: OverlayArrowProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface PopoverProps extends Omit<PositionProps, 'isOpen'>, Omit<AriaPopoverProps, 'popoverRef' | 'triggerRef'>, OverlayTriggerProps, RenderProps<PopoverRenderProps>, SlotProps {
    /**
     * The ref for the element which the popover positions itself with respect to.
     *
     * When used within a trigger component such as DialogTrigger, MenuTrigger, Select, etc.,
     * this is set automatically. It is only required when used standalone.
     */
    triggerRef?: RefObject<Element>;
}
export interface PopoverRenderProps {
    /**
     * The placement of the popover relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
    /**
     * Whether the popover is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the popover is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
}
interface PopoverContextValue extends PopoverProps {
    state: OverlayTriggerState;
    preserveChildren?: boolean;
    triggerRef: RefObject<Element>;
}
export const PopoverContext: React.Context<ContextValue<PopoverContextValue, HTMLElement>>;
/**
 * A popover is an overlay element positioned relative to a trigger.
 */
export const Popover: (props: PopoverProps & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ComboBoxRenderProps {
    /**
     * Whether the combobox is currently open.
     * @selector [data-open]
     */
    isOpen: boolean;
    /**
     * Whether the combobox is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Validation state of the combobox.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | undefined;
    /**
     * Whether the combobox is required.
     * @selector [data-required]
     */
    isRequired: boolean;
    /**
     * State of the combobox.
     */
    state: Omit<ComboBoxState<unknown>, 'children' | 'setOpen' | 'toggle' | 'open' | 'close' | 'selectionManager' | 'setSelectedKey' | 'setFocused' | 'collection' | 'commit' | 'revert'>;
}
export interface ComboBoxProps<T extends object> extends Omit<AriaComboBoxProps<T>, 'children' | 'placeholder' | 'label' | 'description' | 'errorMessage'>, RenderProps<ComboBoxRenderProps>, SlotProps {
    /** The filter function used to determine if a option should be included in the combo box list. */
    defaultFilter?: (textValue: string, inputValue: string) => boolean;
    /**
     * Whether the text or key of the selected item is submitted as part of an HTML form.
     * When `allowsCustomValue` is `true`, this option does not apply and the text is always submitted.
     * @default 'key'
     */
    formValue?: 'text' | 'key';
}
export const ComboBoxContext: React.Context<ContextValue<ComboBoxProps<any>, HTMLDivElement>>;
/**
 * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.
 */
export const ComboBox: <T extends object>(props: ComboBoxProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DateFieldRenderProps {
    /**
     * State of the date field.
     */
    state: DateFieldState;
    /**
     * Validation state of the date field.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState;
    /**
     * Whether the date field is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
export interface DateFieldProps<T extends DateValue> extends Omit<AriaDateFieldProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateFieldRenderProps>, SlotProps {
}
export interface TimeFieldProps<T extends TimeValue> extends Omit<AriaTimeFieldProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateFieldRenderProps>, SlotProps {
}
export const DateFieldContext: React.Context<ContextValue<DateFieldProps<any>, HTMLDivElement>>;
export const TimeFieldContext: React.Context<ContextValue<TimeFieldProps<any>, HTMLDivElement>>;
/**
 * A date field allows users to enter and edit date and time values using a keyboard.
 * Each part of a date value is displayed in an individually editable segment.
 */
export const DateField: <T extends DateValue>(props: DateFieldProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A time field allows users to enter and edit time values using a keyboard.
 * Each part of a time value is displayed in an individually editable segment.
 */
export const TimeField: <T extends TimeValue>(props: TimeFieldProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DateInputRenderProps {
    /**
     * Whether the date input is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether an element within the date input is focused, either via a mouse or keyboard.
     * @selector :focus-within
     */
    isFocusWithin: boolean;
    /**
     * Whether an element within the date input is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the date input is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
export interface DateInputProps extends SlotProps, StyleRenderProps<DateInputRenderProps> {
    children: (segment: _DateSegment1) => ReactElement;
}
/**
 * A date input groups the editable date segments within a date field.
 */
export const DateInput: (props: DateInputProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DateSegmentRenderProps extends Omit<_DateSegment1, 'isEditable'> {
    /**
     * Whether the value is a placeholder.
     * @selector [data-placeholder]
     */
    isPlaceholder: boolean;
    /**
     * Whether the segment is read only.
     * @selector [aria-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the date field is in an invalid state.
     * @selector [aria-invalid]
     */
    isInvalid: boolean;
    /**
     * The type of segment. Values include `literal`, `year`, `month`, `day`, etc.
     * @selector [data-type="..."]
     */
    type: DateSegmentType;
}
export interface DateSegmentProps extends RenderProps<DateSegmentRenderProps> {
    segment: _DateSegment1;
}
/**
 * A date segment displays an individual unit of a date and time, and allows users to edit
 * the value by typing or using the arrow keys to increment and decrement.
 */
export const DateSegment: (props: DateSegmentProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ModalOverlayProps extends AriaModalOverlayProps, OverlayTriggerProps, RenderProps<ModalRenderProps> {
}
interface ModalContextValue {
    state?: OverlayTriggerState;
}
export const ModalContext: React.Context<ModalContextValue>;
export interface ModalRenderProps {
    /**
     * Whether the modal is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the modal is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
    /**
     * State of the modal.
     */
    state: OverlayTriggerState;
}
/**
 * A modal is an overlay element which blocks interaction with elements outside it.
 */
export const Modal: (props: ModalOverlayProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A ModalOverlay is a wrapper for a Modal which allows customizing the backdrop element.
 */
export const ModalOverlay: (props: ModalOverlayProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DialogTriggerProps extends OverlayTriggerProps {
    children: ReactNode;
}
interface DialogRenderProps {
    close: () => void;
}
export interface DialogProps extends AriaDialogProps, StyleProps, SlotProps {
    children?: ReactNode | ((opts: DialogRenderProps) => ReactNode);
    onClose?: () => void;
}
export const DialogContext: React.Context<ContextValue<DialogProps, HTMLElement>>;
/**
 * A DialogTrigger opens a dialog when a trigger element is pressed.
 */
export function DialogTrigger(props: DialogTriggerProps): React.JSX.Element;
/**
 * A dialog is an overlay shown above other content in an application.
 */
export const Dialog: (props: DialogProps & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface GroupRenderProps {
    /**
     * Whether the group is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether an element within the group is focused, either via a mouse or keyboard.
     * @selector :focus-within
     */
    isFocusWithin: boolean;
    /**
     * Whether an element within the group is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
}
export interface GroupProps extends Omit<HTMLAttributes<HTMLElement>, 'className' | 'style'>, StyleRenderProps<GroupRenderProps> {
}
export const GroupContext: React.Context<ContextValue<GroupProps, HTMLDivElement>>;
/**
 * An group represents a set of related UI controls.
 */
export const Group: React.ForwardRefExoticComponent<GroupProps & React.RefAttributes<HTMLDivElement>>;
export interface DatePickerRenderProps {
    /**
     * Whether an element within the date picker is focused, either via a mouse or keyboard.
     * @selector :focus-within
     */
    isFocusWithin: boolean;
    /**
     * Whether an element within the date picker is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the date picker is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * State of the date picker.
     */
    state: DatePickerState;
    /**
     * Validation state of the date picker.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState;
}
export interface DateRangePickerRenderProps extends Omit<DatePickerRenderProps, 'state'> {
    /**
     * State of the date range picker.
     */
    state: DateRangePickerState;
}
export interface DatePickerProps<T extends DateValue> extends Omit<AriaDatePickerProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DatePickerRenderProps>, SlotProps {
}
export interface DateRangePickerProps<T extends DateValue> extends Omit<AriaDateRangePickerProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateRangePickerRenderProps>, SlotProps {
}
export const DatePickerContext: React.Context<ContextValue<DatePickerProps<any>, HTMLDivElement>>;
export const DateRangePickerContext: React.Context<ContextValue<DateRangePickerProps<any>, HTMLDivElement>>;
/**
 * A date picker combines a DateField and a Calendar popover to allow users to enter or select a date and time value.
 */
export const DatePicker: <T extends DateValue>(props: DatePickerProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A date range picker combines two DateFields and a RangeCalendar popover to allow
 * users to enter or select a date and time range.
 */
export const DateRangePicker: <T extends DateValue>(props: DateRangePickerProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DropZoneRenderProps {
    /**
     * Whether the dropzone is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the dropzone is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the dropzone is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the dropzone is the drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
export interface DropZoneProps extends Omit<DropOptions, 'getDropOperationForPoint' | 'ref' | 'hasDropButton'>, RenderProps<DropZoneRenderProps>, SlotProps, AriaLabelingProps {
}
export const DropZoneContext: React.Context<ContextValue<DropZoneProps, HTMLDivElement>>;
/**
 * A drop zone is an area into which one or multiple objects can be dragged and dropped.
 */
export const DropZone: React.ForwardRefExoticComponent<DropZoneProps & React.RefAttributes<HTMLDivElement>>;
export interface FileTriggerProps {
    /**
     * Specifies what mime type of files are allowed.
     */
    acceptedFileTypes?: Array<string>;
    /**
     * Whether multiple files can be selected.
     */
    allowsMultiple?: boolean;
    /**
     * Specifies the use of a media capture mechanism to capture the media on the spot.
     */
    defaultCamera?: 'user' | 'environment';
    /**
     * Handler when a user selects a file.
     */
    onChange?: (files: FileList | null) => void;
    /**
     * The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).
     */
    name?: string;
    /**
     * The children of the component.
     */
    children?: ReactNode;
}
/**
 * A FileTrigger allows a user to access the file system with any pressable React Aria or React Spectrum component, or custom components built with usePress.
 */
export const FileTrigger: React.ForwardRefExoticComponent<FileTriggerProps & React.RefAttributes<HTMLInputElement>>;
export interface GridListRenderProps {
    /**
     * Whether the list has no items and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the grid list is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the grid list is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the grid list is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
    /**
     * State of the grid list.
     */
    state: ListState<unknown>;
}
export interface GridListProps<T> extends Omit<AriaGridListProps<T>, 'children'>, CollectionProps<T>, StyleRenderProps<GridListRenderProps>, SlotProps {
    /** How multiple selection should behave in the collection. */
    selectionBehavior?: SelectionBehavior;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the GridList. */
    dragAndDropHooks?: DragAndDropHooks;
    /** Provides content to display when there are no items in the list. */
    renderEmptyState?: () => ReactNode;
}
export const GridListContext: React.Context<ContextValue<GridListProps<any>, HTMLDivElement>>;
/**
 * A grid list displays a list of interactive items, with support for keyboard navigation,
 * single or multiple selection, and row actions.
 */
export const GridList: <T extends object>(props: GridListProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export const KeyboardContext: React.Context<ContextValue<React.HTMLAttributes<HTMLElement>, HTMLElement>>;
export const Keyboard: React.ForwardRefExoticComponent<React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>>;
export const MenuContext: React.Context<ContextValue<MenuProps<any>, HTMLDivElement>>;
export interface MenuTriggerProps extends _MenuTriggerProps1 {
    children?: ReactNode;
}
export function MenuTrigger(props: MenuTriggerProps): React.JSX.Element;
export interface MenuProps<T> extends Omit<AriaMenuProps<T>, 'children'>, CollectionProps<T>, StyleProps, SlotProps {
}
/**
 * A menu displays a list of actions or options that a user can choose.
 */
export const Menu: <T extends object>(props: MenuProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface MenuItemRenderProps extends ItemRenderProps {
    /**
     * Whether the item is currently selected.
     * @selector [aria-checked=true]
     */
    isSelected: boolean;
}
export interface MeterProps extends Omit<AriaMeterProps, 'label'>, RenderProps<MeterRenderProps>, SlotProps {
}
export interface MeterRenderProps {
    /**
     * The value as a percentage between the minimum and maximum.
     */
    percentage: number;
    /**
     * A formatted version of the value.
     * @selector [aria-valuetext]
     */
    valueText: string | undefined;
}
export const MeterContext: React.Context<ContextValue<MeterProps, HTMLDivElement>>;
/**
 * A meter represents a quantity within a known range, or a fractional value.
 */
export const Meter: (props: MeterProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface NumberFieldRenderProps {
    /**
     * Whether the number field is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Validation state of the number field.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | undefined;
    /**
     * State of the number field.
     */
    state: NumberFieldState;
}
export interface NumberFieldProps extends Omit<AriaNumberFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, InputDOMProps, RenderProps<NumberFieldRenderProps>, SlotProps {
}
export const NumberFieldContext: React.Context<ContextValue<NumberFieldProps, HTMLDivElement>>;
/**
 * A number field allows a user to enter a number, and increment or decrement the value using stepper buttons.
 */
export const NumberField: (props: NumberFieldProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ProgressBarProps extends Omit<AriaProgressBarProps, 'label'>, RenderProps<ProgressBarRenderProps>, SlotProps {
}
export interface ProgressBarRenderProps {
    /**
     * The value as a percentage between the minimum and maximum.
     */
    percentage?: number;
    /**
     * A formatted version of the value.
     * @selector [aria-valuetext]
     */
    valueText: string | undefined;
    /**
     * Whether the progress bar is indeterminate.
     * @selector :not([aria-valuenow])
     */
    isIndeterminate: boolean;
}
export const ProgressBarContext: React.Context<ContextValue<ProgressBarProps, HTMLDivElement>>;
/**
 * Progress bars show either determinate or indeterminate progress of an operation
 * over time.
 */
export const ProgressBar: React.ForwardRefExoticComponent<ProgressBarProps & React.RefAttributes<HTMLDivElement>>;
export interface RadioGroupProps extends Omit<AriaRadioGroupProps, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<RadioGroupRenderProps>, SlotProps {
}
export interface RadioProps extends Omit<AriaRadioProps, 'children'>, RenderProps<RadioRenderProps>, SlotProps {
}
export interface RadioGroupRenderProps {
    /**
     * The orientation of the radio group.
     * @selector [aria-orientation="horizontal | vertical"]
     */
    orientation: _Orientation1;
    /**
     * Whether the radio group is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the radio group is read only.
     * @selector [aria-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the radio group is required.
     * @selector [aria-required]
     */
    isRequired: boolean;
    /**
     * The validation state of the radio group.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | null;
    /**
     * State of the radio group.
     */
    state: RadioGroupState;
}
export interface RadioRenderProps {
    /**
     * Whether the radio is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the radio is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the radio is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the radio is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the radio is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the radio is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the radio is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the radio is valid or invalid.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | null;
    /**
     * Whether the checkbox is required.
     * @selector [data-required]
     */
    isRequired: boolean;
}
export const RadioGroupContext: React.Context<ContextValue<RadioGroupProps, HTMLDivElement>>;
export const RadioContext: React.Context<ContextValue<Partial<RadioProps>, HTMLInputElement>>;
/**
 * A radio group allows a user to select a single item from a list of mutually exclusive options.
 */
export const RadioGroup: (props: RadioGroupProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A radio represents an individual option within a radio group.
 */
export const Radio: (props: RadioProps & React.RefAttributes<HTMLInputElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SearchFieldRenderProps {
    /**
     * Whether the search field is empty.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the search field is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Validation state of the search field.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | undefined;
    /**
     * State of the search field.
     */
    state: SearchFieldState;
}
export interface SearchFieldProps extends Omit<AriaSearchFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, RenderProps<SearchFieldRenderProps>, SlotProps {
}
export const SearchFieldContext: React.Context<ContextValue<SearchFieldProps, HTMLDivElement>>;
/**
 * A search field allows a user to enter and clear a search query.
 */
export const SearchField: (props: SearchFieldProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SelectRenderProps {
    /**
     * Whether the select is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the select is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the select is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the select is currently open.
     * @selector [data-open]
     */
    isOpen: boolean;
    /**
     * Validation state of the select.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | undefined;
    /**
     * Whether the select is required.
     * @selector [data-required]
     */
    isRequired: boolean;
    /**
     * State of the select.
     */
    state: Omit<SelectState<unknown>, 'open' | 'toggle' | 'collection' | 'disabledKeys' | 'selectionManager' | 'setSelectedKey'>;
}
export interface SelectProps<T extends object> extends Omit<AriaSelectProps<T>, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<SelectRenderProps>, SlotProps {
}
export const SelectContext: React.Context<ContextValue<SelectProps<any>, HTMLDivElement>>;
/**
 * A select displays a collapsible list of options and allows a user to select one of them.
 */
export const Select: <T extends object>(props: SelectProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SelectValueRenderProps<T> {
    /**
     * Whether the value is a placeholder.
     * @selector [data-placeholder]
     */
    isPlaceholder: boolean;
    /** The object value of the currently selected item. */
    selectedItem: T | null;
    /** The textValue of the currently selected item. */
    selectedText: string | null;
}
export interface SelectValueProps<T extends object> extends Omit<HTMLAttributes<HTMLElement>, keyof RenderProps<unknown>>, RenderProps<SelectValueRenderProps<T>> {
}
/**
 * SelectValue renders the current value of a Select, or a placeholder if no value is selected.
 * It is usually placed within the button element.
 */
export const SelectValue: <T extends object>(props: SelectValueProps<T> & React.RefAttributes<HTMLSpanElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderProps<T = number | number[]> extends AriaSliderProps<T>, RenderProps<SliderRenderProps>, SlotProps {
    /**
     * The display format of the value label.
     */
    formatOptions?: Intl.NumberFormatOptions;
}
export const SliderContext: React.Context<ContextValue<SliderProps<number | number[]>, HTMLDivElement>>;
export interface SliderRenderProps {
    /**
     * The orientation of the slider.
     * @selector [data-orientation="horizontal | vertical"]
     */
    orientation: _Orientation1;
    /**
     * Whether the slider is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * State of the slider.
     */
    state: SliderState;
}
/**
 * A slider allows a user to select one or more values within a range.
 */
export const Slider: <T extends number | number[]>(props: SliderProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderOutputProps extends RenderProps<SliderRenderProps> {
}
/**
 * A slider output displays the current value of a slider as text.
 */
export const SliderOutput: (props: SliderOutputProps & React.RefAttributes<HTMLOutputElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderTrackRenderProps extends SliderRenderProps {
    /**
     * Whether the slider track is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
}
export interface SliderTrackProps extends RenderProps<SliderTrackRenderProps> {
}
/**
 * A slider track is a container for one or more slider thumbs.
 */
export const SliderTrack: (props: SliderTrackProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderThumbRenderProps {
    /**
     * State of the slider.
     */
    state: SliderState;
    /**
     * Whether this thumb is currently being dragged.
     * @selector [data-dragging]
     */
    isDragging: boolean;
    /**
     * Whether the thumb is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the thumb is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the thumb is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the thumb is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
export interface SliderThumbProps extends AriaSliderThumbProps, RenderProps<SliderThumbRenderProps> {
}
/**
 * A slider thumb represents an individual value that the user can adjust within a slider track.
 */
export const SliderThumb: (props: SliderThumbProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SwitchProps extends Omit<AriaSwitchProps, 'children'>, RenderProps<SwitchRenderProps>, SlotProps {
}
export interface SwitchRenderProps {
    /**
     * Whether the switch is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the switch is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the switch is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the switch is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the switch is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the switch is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the switch is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * State of the switch.
     */
    state: ToggleState;
}
export const SwitchContext: React.Context<ContextValue<SwitchProps, HTMLInputElement>>;
/**
 * A switch allows a user to turn a setting on or off.
 */
export const Switch: (props: SwitchProps & React.RefAttributes<HTMLInputElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ResizableTableContainerProps extends DOMProps {
    /**
     * Handler that is called when a user starts a column resize.
     */
    onResizeStart?: (widths: Map<Key, ColumnSize>) => void;
    /**
     * Handler that is called when a user performs a column resize.
     * Can be used with the width property on columns to put the column widths into
     * a controlled state.
     */
    onResize?: (widths: Map<Key, ColumnSize>) => void;
    /**
     * Handler that is called after a user performs a column resize.
     * Can be used to store the widths of columns for another future session.
     */
    onResizeEnd?: (widths: Map<Key, ColumnSize>) => void;
}
export const ResizableTableContainer: React.ForwardRefExoticComponent<ResizableTableContainerProps & React.RefAttributes<HTMLDivElement>>;
export const TableContext: React.Context<ContextValue<TableProps, HTMLTableElement>>;
export interface TableRenderProps {
    /**
     * Whether the table is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the table is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the table is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
    /**
     * State of the table.
     */
    state: TableState<unknown>;
}
export interface TableProps extends Omit<_TableProps1<any>, 'children'>, StyleRenderProps<TableRenderProps>, SlotProps, AriaLabelingProps {
    /** The elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows. */
    children?: ReactNode;
    /**
     * How multiple selection should behave in the collection.
     * @default "toggle"
     */
    selectionBehavior?: SelectionBehavior;
    /**
     * Whether `disabledKeys` applies to all interactions, or only selection.
     * @default "selection"
     */
    disabledBehavior?: DisabledBehavior;
    /** Handler that is called when a user performs an action on the row. */
    onRowAction?: (key: Key) => void;
    /** Handler that is called when a user performs an action on the cell. */
    onCellAction?: (key: Key) => void;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the Table. */
    dragAndDropHooks?: DragAndDropHooks;
}
/**
 * A table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,
 * and optionally supports row selection and sorting.
 */
export const Table: React.ForwardRefExoticComponent<TableProps & React.RefAttributes<HTMLTableElement>>;
interface TableOptionsContextValue {
    /** The type of selection that is allowed in the table. */
    selectionMode: SelectionMode;
    /** The selection behavior for the table. If selectionMode is `"none"`, this will be `null`. */
    selectionBehavior: SelectionBehavior | null;
    /** Whether the table allows empty selection. */
    disallowEmptySelection: boolean;
    /** Whether the table allows rows to be dragged. */
    allowsDragging: boolean;
}
/**
 * Returns options from the parent `<Table>` component.
 */
export function useTableOptions(): TableOptionsContextValue;
export interface TableHeaderProps<T> extends StyleProps {
    /** A list of table columns. */
    columns?: T[];
    /** A list of `Column(s)` or a function. If the latter, a list of columns must be provided using the `columns` prop. */
    children?: ReactNode | ((item: T) => ReactElement);
}
/**
 * A header within a `<Table>`, containing the table columns.
 */
export const TableHeader: <T extends object>(props: TableHeaderProps<T> & React.RefAttributes<HTMLTableSectionElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ColumnRenderProps {
    isHovered: boolean;
    /**
     * Whether the item is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the item is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the column allows sorting.
     * @selector [aria-sort]
     */
    allowsSorting: boolean;
    /**
     * The current sort direction.
     * @selector [aria-sort="ascending | descending"]
     */
    sortDirection?: SortDirection;
    /**
     * Whether the column is currently being resized.
     * @selector [data-resizing]
     */
    isResizing: boolean;
    /**
     * Triggers sorting for this column in the given direction.
     */
    sort(direction: SortDirection): void;
    /**
     * Starts column resizing if the table is contained in a `<ResizableTableContainer>` element.
     */
    startResize(): void;
}
export interface ColumnProps<T = object> extends RenderProps<ColumnRenderProps> {
    id?: Key;
    /** Rendered contents of the column if `children` contains child columns. */
    title?: ReactNode;
    /** A list of child columns used when dynamically rendering nested child columns. */
    childColumns?: Iterable<T>;
    /** Whether the column allows sorting. */
    allowsSorting?: boolean;
    /** Whether a column is a [row header](https://www.w3.org/TR/wai-aria-1.1/#rowheader) and should be announced by assistive technology during row navigation. */
    isRowHeader?: boolean;
    /** A string representation of the column's contents, used for accessibility announcements. */
    textValue?: string;
    /** The width of the column. This prop only applies when the `<Table>` is wrapped in a `<ResizableTableContainer>`. */
    width?: ColumnSize | null;
    /** The default width of the column. This prop only applies when the `<Table>` is wrapped in a `<ResizableTableContainer>`. */
    defaultWidth?: ColumnSize | null;
    /** The minimum width of the column. This prop only applies when the `<Table>` is wrapped in a `<ResizableTableContainer>`. */
    minWidth?: ColumnStaticSize | null;
    /** The maximum width of the column. This prop only applies when the `<Table>` is wrapped in a `<ResizableTableContainer>`. */
    maxWidth?: ColumnStaticSize | null;
}
/**
 * A column within a `<Table>`.
 */
export const Column: <T extends object>(props: ColumnProps<T> & React.RefAttributes<HTMLTableCellElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TableBodyRenderProps {
    /**
     * Whether the table body has no rows and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
}
export interface TableBodyProps<T> extends CollectionProps<T>, StyleRenderProps<TableBodyRenderProps> {
    /** Provides content to display when there are no rows in the table. */
    renderEmptyState?: () => ReactNode;
}
/**
 * The body of a `<Table>`, containing the table rows.
 */
export const TableBody: <T extends object>(props: TableBodyProps<T> & React.RefAttributes<HTMLTableSectionElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface RowRenderProps extends ItemRenderProps {
}
export interface RowProps<T> extends StyleRenderProps<RowRenderProps> {
    id?: Key;
    /** A list of columns used when dynamically rendering cells. */
    columns?: Iterable<T>;
    /** The cells within the row. Supports static items or a function for dynamic rendering. */
    children?: ReactNode | ((item: T) => ReactElement);
    /** A string representation of the row's contents, used for features like typeahead. */
    textValue?: string;
}
/**
 * A row within a `<Table>`.
 */
export const Row: <T extends object>(props: RowProps<T> & React.RefAttributes<HTMLTableRowElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CellRenderProps {
    /**
     * Whether the cell is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the cell is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the cell is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the cell is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
}
export interface CellProps extends RenderProps<CellRenderProps> {
    id?: Key;
    /** The contents of the cell. */
    children: ReactNode;
    /** A string representation of the cell's contents, used for features like typeahead. */
    textValue?: string;
}
/**
 * A cell within a table row.
 */
export const Cell: React.ForwardRefExoticComponent<CellProps & React.RefAttributes<HTMLTableCellElement>>;
export interface ColumnResizerRenderProps {
    /**
     * Whether the resizer is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the resizer is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the resizer is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the resizer is currently being resized.
     * @selector [data-resizing]
     */
    isResizing: boolean;
    /**
     * The direction that the column is currently resizable.
     * @selector [data-resizable-direction="right | left | both"]
     */
    resizableDirection: 'right' | 'left' | 'both';
}
export interface ColumnResizerProps extends RenderProps<ColumnResizerRenderProps> {
    /** A custom accessibility label for the resizer. */
    'aria-label'?: string;
}
export const ColumnResizer: React.ForwardRefExoticComponent<ColumnResizerProps & React.RefAttributes<HTMLDivElement>>;
export interface TabsProps extends Omit<AriaTabListProps<any>, 'items' | 'children'>, RenderProps<TabsRenderProps>, SlotProps {
}
export interface TabsRenderProps {
    /**
     * The orientation of the tabs.
     * @selector [data-orientation="horizontal | vertical"]
     */
    orientation: _Orientation1;
    /**
     * State of the tab list.
     */
    state: Omit<TabListState<unknown>, 'selectionManager' | 'selectedItem' | 'collection'>;
}
export interface TabListProps<T> extends StyleRenderProps<TabListRenderProps>, AriaLabelingProps, Omit<CollectionProps<T>, 'disabledKeys'> {
}
export interface TabListRenderProps {
    /**
     * The orientation of the tab list.
     * @selector [aria-orientation="horizontal | vertical"]
     */
    orientation: _Orientation1;
    /**
     * State of the tab list.
     */
    state: TabListState<unknown>;
}
export interface TabProps extends RenderProps<TabRenderProps>, AriaLabelingProps {
    id?: Key;
}
export interface TabRenderProps {
    /**
     * Whether the tab is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the tab is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the tab is currently selected.
     * @selector [aria-selected=true]
     */
    isSelected: boolean;
    /**
     * Whether the tab is currently focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the tab is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the tab is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
}
export interface TabPanelProps extends AriaTabPanelProps, RenderProps<TabPanelRenderProps> {
    /**
     * Whether to mount the tab panel in the DOM even when it is not currently selected.
     * Inactive tab panels are inert and cannot be interacted with. They must be styled appropriately so this is clear to the user visually.
     * @default false
     */
    shouldForceMount?: boolean;
}
export interface TabPanelRenderProps {
    /**
     * Whether the tab panel is currently focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the tab panel is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the tab panel is currently non-interactive. This occurs when the
     * `shouldForceMount` prop is true, and the corresponding tab is not selected.
     * @selector [inert]
     */
    isInert: boolean;
    /**
     * State of the tab list.
     */
    state: TabListState<unknown>;
}
export const TabsContext: React.Context<ContextValue<TabsProps, HTMLDivElement>>;
/**
 * Tabs organize content into multiple sections and allow users to navigate between them.
 */
export const Tabs: (props: TabsProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A TabList is used within Tabs to group tabs that a user can switch between.
 * The ids of the items within the <TabList> must match up with a corresponding item inside the <TabPanels>.
 */
export const TabList: <T extends object>(props: TabListProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A Tab provides a title for an individual item within a TabList.
 */
export const Tab: (props: TabProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A TabPanel provides the content for a tab.
 */
export const TabPanel: (props: TabPanelProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TagGroupProps extends Omit<AriaTagGroupProps<unknown>, 'children' | 'items' | 'label' | 'description' | 'errorMessage' | 'keyboardDelegate'>, DOMProps, SlotProps {
}
export interface TagListRenderProps {
    /**
     * Whether the tag list has no items and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the tag list is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the tag list is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
}
export interface TagListProps<T> extends Omit<CollectionProps<T>, 'disabledKeys'>, StyleRenderProps<TagListRenderProps> {
    /** Provides content to display when there are no items in the tag list. */
    renderEmptyState?: () => ReactNode;
}
export const TagGroupContext: React.Context<ContextValue<TagGroupProps, HTMLDivElement>>;
/**
 * A tag group is a focusable list of labels, categories, keywords, filters, or other items, with support for keyboard navigation, selection, and removal.
 */
export const TagGroup: (props: TagGroupProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A tag list is a container for tags within a TagGroup.
 */
export const TagList: <T extends object>(props: TagListProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TagRenderProps extends Omit<ItemRenderProps, 'allowsDragging' | 'isDragging' | 'isDropTarget'> {
    /**
     * Whether the tag group allows items to be removed.
     * @selector [data-allows-removing]
     */
    allowsRemoving: boolean;
}
export interface TagProps extends RenderProps<TagRenderProps> {
    /** A unique id for the tag. */
    id?: Key;
    /**
     * A string representation of the tags's contents, used for accessibility.
     * Required if children is not a plain text string.
     */
    textValue?: string;
}
/**
 * A Tag is an individual item within a TagList.
 */
export const Tag: (props: TagProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TextAreaProps extends Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, 'className' | 'style'>, StyleRenderProps<InputRenderProps> {
}
export const TextAreaContext: React.Context<ContextValue<TextAreaProps, HTMLTextAreaElement>>;
/**
 * A textarea allows a user to input mult-line text.
 */
export const TextArea: React.ForwardRefExoticComponent<TextAreaProps & React.RefAttributes<HTMLTextAreaElement>>;
export interface TextFieldRenderProps {
    /**
     * Whether the text field is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Validation state of the text field.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: _ValidationState1 | undefined;
}
export interface TextFieldProps extends Omit<AriaTextFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, Omit<DOMProps, 'style' | 'className' | 'children'>, SlotProps, RenderProps<TextFieldRenderProps> {
}
export const TextFieldContext: React.Context<ContextValue<TextFieldProps, HTMLDivElement>>;
/**
 * A text field allows a user to enter a plain text value with a keyboard.
 */
export const TextField: (props: TextFieldProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ToggleButtonRenderProps extends ButtonRenderProps {
    /**
     * Whether the button is currently selected.
     * @selector [aria-pressed=true]
     */
    isSelected: boolean;
    /**
     * State of the toggle button.
     */
    state: ToggleState;
}
export interface ToggleButtonProps extends Omit<AriaToggleButtonProps, 'children' | 'elementType'>, SlotProps, RenderProps<ToggleButtonRenderProps> {
}
export const ToggleButtonContext: React.Context<ContextValue<ToggleButtonProps, HTMLButtonElement>>;
/**
 * A toggle button allows a user to toggle a selection on or off, for example switching between two states or modes.
 */
export const ToggleButton: (props: ToggleButtonProps & React.RefAttributes<HTMLButtonElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface TooltipTriggerComponentProps extends TooltipTriggerProps {
    children: ReactNode;
}
export interface TooltipProps extends PositionProps, AriaLabelingProps, RenderProps<TooltipRenderProps> {
}
export interface TooltipRenderProps {
    /**
     * The placement of the tooltip relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
    /**
     * Whether the tooltip is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the tooltip is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
    /**
     * State of the tooltip.
     */
    state: TooltipTriggerState;
}
/**
 * TooltipTrigger wraps around a trigger element and a Tooltip. It handles opening and closing
 * the Tooltip when the user hovers over or focuses the trigger, and positioning the Tooltip
 * relative to the trigger.
 */
export function TooltipTrigger(props: TooltipTriggerComponentProps): React.JSX.Element;
/**
 * A tooltip displays a description of an element on hover or focus.
 */
export const Tooltip: (props: TooltipProps & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export { DIRECTORY_DRAG_TYPE, isDirectoryDropItem, isFileDropItem, isTextDropItem, SSRProvider } from 'react-aria';
export type { DateValue, DateRange, TimeValue } from 'react-aria';
export type { DirectoryDropItem, DraggableCollectionEndEvent, DraggableCollectionMoveEvent, DraggableCollectionStartEvent, DragPreviewRenderer, DragTypes, DropItem, DropOperation, DroppableCollectionDropEvent, DroppableCollectionEnterEvent, DroppableCollectionExitEvent, DroppableCollectionInsertDropEvent, DroppableCollectionMoveEvent, DroppableCollectionOnItemDropEvent, DroppableCollectionReorderEvent, DroppableCollectionRootDropEvent, DropPosition, DropTarget, FileDropItem, ItemDropTarget, RootDropTarget, TextDropItem } from 'react-aria';
export type { Selection, SortDescriptor, SortDirection } from 'react-stately';

//# sourceMappingURL=types.d.ts.map
